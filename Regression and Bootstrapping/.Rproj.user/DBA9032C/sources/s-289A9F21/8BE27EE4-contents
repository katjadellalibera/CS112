#q1
set.seed(123)
x<-c(1:99)
y<-0.05*x + 5 +rnorm(99,0, 1)   #Generating the data and adding noise
model1<-lm(y~x)        #Creating the Linear Model
plot(x, y, pch=19)     #plotting, and customizing the point shape
abline(model1)
summary(model1)


y1<-c(y,-30)          #Adding the outlier, then repeating the previous process
x1<-c((1:99),200)
model2<-lm(y1~x1)
summary(model2)
plot(x1,y1,pch=19)
abline(model2)


plot(x1, y1, ylab='y',xlab='x', pch=19)        #Plotting the data and regression lines
abline(model1,col='red')
abline(model2,col='blue')


#q2
set.seed(123)
library(arm)
library(dplyr)
data(lalonde)
df<-lalonde
df<-df%>%filter(treat==0)               #Filtering the dataframe to only include the control group and relevant columns
keep<-c("age","educ","re74","re75","re78")
df<-df[keep]
lm <- lm(re78 ~ age+educ+re74+re75+educ*re74+educ*re75+age*re74+age*re75+re74*re75, data = df)
summary(lm)

get_re78_val<- function(coefs,col,sig) {                  #defining a function to find the value of re78 from the regression model
  re78_estimate<-coefs[1] + coefs[2]*col[1] + 
    coefs[3]*col[2] + coefs[4]*col[3] + 
    coefs[5]*col[4] + coefs[6]*col[2]*col[3] + 
    coefs[7]*col[2]*col[4] + coefs[8]*col[1]*col[3] + 
    coefs[9]*col[1]*col[4] + coefs[10]*col[3]*col[4] +rnorm(1,0,sig)       #This is where the simulated sigmas were included
  return(re78_estimate)
}

sim.lm<-sim(lm,10000)         #Simulate the function and storing the values of sigma
sig<-sim.lm@sigma

storage.matrix1<-matrix(NA,nrow=10000,ncol=39)        #Creating a matrix to store 10000 predicted ys for each age
for(age in c(17:55)) {
  for(i in 1:10000) {
    random.person<- c(age,median(df$educ),median(df$re74),median(df$re75))
    storage.matrix1[i,age-16]<- get_re78_val(coefs=sim.lm@coef[i, ], col=random.person,sig=sig[i])
  }
}
conf.int1 <- apply(storage.matrix1, 2, quantile, probs = c(0.025, 0.975))    #Calculating confidence intervals from simulation

plot(x = c(-20000:20000), y = c(-20000:20000), type = "n", xlim = c(17,55), xlab='Age',ylab="Predicted Earnings in 1978",main="Predicted Earnings vs. Age")
for (age in 17:55) {
  segments(                                   #Generate plot
    x0 = age,
    y0 = conf.int1[1, age - 16],
    x1 = age,
    y1 = conf.int1[2, age - 16])
}

pred_ys<-rep(0,39)               #Regenerating predicted ys from the initial linear model (before simulation) for the table
for(i in c(17:55)) {
  random.person<- c(i,median(df$educ),median(df$re74),median(df$re75))
  se <- sqrt(diag(vcov(lm)))
  pred_ys[i-16]<-get_re78_val(coefs=lm$coef, col=random.person,sig=se[2])
}

low_bound<-rep(0,39)                   #Lower and upper bounds of prediction interval
for(i in c(17:55)) {
  low_bound[i-16]<-conf.int1[1,i-16]
}

upper_bound<-c(0,39)
for(i in c(17:55)) {
  upper_bound[i-16]<-conf.int1[2,i-16]
}

ages<-c(17:55)

tableresults<-data.frame(ages,pred_ys,low_bound,upper_bound)
colnames(tableresults)<-c("Age","Predicted Earnings for 1978","Lower Bound - 2.5%","Upper Bound - 97.5%")
head(tableresults)

#Q2 where the variables are held at 90th quantile
#same process as before
set.seed(123)
sim.lm<-sim(lm,10000)

storage.matrix2<-matrix(NA,nrow=10000,ncol=39)
for(age in c(17:55)) {
  for(i in 1:10000) {
    random.person<- c(age,quantile(df$educ,0.9),quantile(df$re74,0.9),quantile(df$re75,0.9))
    storage.matrix2[i,age-16]<- get_re78_val(sim.lm@coef[i, ], random.person,sig=sig[i])
  }
}
conf.int2 <- apply(storage.matrix2, 2, quantile, probs = c(0.025, 0.975))

plot(x = c(-20000:20000), y = c(-20000:20000), type = "n", xlim = c(17,55), xlab='Age',ylab="Predicted Earnings in 1978",main="Predicted Earnings vs. Age")
for (age in 17:55) {
  segments(
    x0 = age,
    y0 = conf.int2[1, age - 16],
    x1 = age,
    y1 = conf.int2[2, age - 16])
}

pred_ys<-rep(0,39)
for(i in c(17:55)) {
  random.person<- c(i,quantile(df$educ,0.9),quantile(df$re74,0.9),quantile(df$re75,0.9))
  se <- sqrt(diag(vcov(lm)))
  pred_ys[i-16]<-get_re78_val(coefs=lm$coef, col=random.person,sig=se[2])
}

low_bound<-rep(0,39)
for(i in c(17:55)) {
  low_bound[i-16]<-conf.int2[1,i-16]
}

upper_bound<-c(0,39)
for(i in c(17:55)) {
  upper_bound[i-16]<-conf.int2[2,i-16]
}

ages<-c(17:55)

tableresults<-data.frame(ages,pred_ys,low_bound,upper_bound)
colnames(tableresults)<-c("Age","Predicted Earnings for 1978","Lower Bound - 2.5%","Upper Bound - 97.5%")
head(tableresults)


#q3
set.seed(123)
library(haven)
df2<-read_dta("C:/Users/yanal/Desktop/nsw.dta")
mod<-lm(re78~treat,data=df2)
summary(mod)                            #Generating a linear model
#analytical confidence interval
confindence_interval<-confint(mod)           #Finding a confidence interval and specifying the confidence interval for treatment
confindence_interval[2,]                     #and not both treatment and intercept
#bootstrap
coeff_storage<-rep(0,10000)           #Creating a vector to store generated coefficient values
keep2<-c('treat','re78')              #Keeping two relevant columns in dataframe to make pulling out samples easier
df3<-df2[keep2]
for(i in c(1:10000)) {
  rows<-sample(c(1:722),722,replace=TRUE)    #Sampling indices at random then selecting rows from dataframe
  df_sample<-df3[rows,]                      #that match indices to generate a new dataframe with sampled rows
  model_bootstrap<-lm(re78~treat,data=df_sample)    #Creating the linear model
  coeff_storage[i]<-model_bootstrap$coefficients[2]  #Storing the coefficients generated by the model
}

quantile(coeff_storage,probs = c(0.025, 0.975))         #Obtaining the 95% confidence interval from the bootstrap

hist(coeff_storage,breaks=20,xlab="Bootstrap Coefficients",main="Distribution of Bootstrap Coefficients") #Generate histogram


#q4
#Function
r_squared<-function(actual_ys,pred_ys) {
  rss<-sum((predicted-actual)^2)
  tss<-sum((actual-(mean(actual)))^2)
  r2<-(1-(rss/tss))
  return(r2)
}

#Example
predicted<-886.3*(df2$treat)+5090
actual<-df2$re78
r_squared(actual,predicted)
#Compare to the actual value of r^2 obtained from the summary of lm()
summary(lm(re78~treat,data=df2))


#q5
library(dplyr)
set.seed(123)
df2<-read_dta("C:/Users/yanal/Desktop/nsw.dta")
model<-glm(treat~age+education+black+hispanic+married+nodegree+re75,data=df2,family=binomial) #Create the model to predict
#probability of being assigned to treatment
df_treat<-df2%>%filter(treat==1)        #Splitting the data set. This is the treatment group only
probs_treat<-predict(model,df_treat,type='response')   #Generates probability of being assigned to treatment for those already in treatment
#h1=hist(probs_treat,breaks=40)

df_control<-df2%>%filter(treat==0)     #Control group only
probs_control<-predict(model,df_control,type='response')   #probability of being assigned to treatment for those assigned to control
#h2=hist(probs_control,breaks=40)

plot(h2,col=rgb(0,0,1,1/4),xlab="Propensity Score",main="Propensity Score Distribution")   #Generating histogram
plot(h1,col=rgb(1,0,0,1/4),add=T)
legend("topright", c("Treatment Group", "Control Group"), col=c(rgb(1,0,0,1/4), rgb(0,0,1,1/4)), lwd=10)